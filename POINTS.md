# OWNERSHIP

- 全ての値は１つの所有者のみに所有される
- 一部のプリミティブ型には所有権が適用されない（Copy型という）
- 参照カウントを用いることで１つの値が複数所有されることができる

# MOVE

- 代入や所有権の移動はポインタなどの値が移動するだけでHeap上の値が別の場所に移動されるわけではない
- vectorのindexアクセスではmoveできない
- Option型を使用することでindexアクセスした場合でも所有権を移動できる
- Copy型ではないものの簡単な考え方
  - 値をドロップする際に何かしなければならいものはCopy型ではない

# RcとArc

- RcかArcを利用することで複数の所有者を持つ値が作れる
- ArcはAtomic reference countでスレッド間で所有権を共有する時に利用する
  - スレッド間でRcを利用して所有権を利用することはできない

# 借用(borrowing)と参照(reference)

- 参照のルール
  - 共有参照
    - 共有参照を用いると読み取りはできるが書き込みはできない
    - いくらでも共有参照を持つことができる
    - 型Tの共有参照型は&T（ref Tと発音する)
  - 可変参照
    - 値の可変参照を用いると値を読み出すことも書き出すこともできる
    - 同じ値に対する可変参照とその他の参照は同時に存在できない
    - &mut TがTに対する可変参照（ref mute Tと発音する
    - 可変参照はCopy型ではない
  - 複数の読み出しか単一書き込みのルール
  - ある値の共有参照がある間は所有者であっても値を変更することができない
  - 値渡し
    - 関数に値の所有権を渡すこと
  - 参照渡し
    - 関数に値の参照を渡すこと。所有権は移動しない。
- 参照の解決はC++と違い明示的に行う必要がある
  - ただし、構造体メンバへのアクセスなどの`.`を使う場合は暗黙的に参照解決を行うことができる
  - 参照に代入をすると別の場所を指すようになる
    - これはC++の代入の動作とは異なる
- 参照の参照もある
  - .演算子は何段の参照でも参照解決を暗黙的に行う
- 比較演算子も参照解決して比較できる
  - ただし、参照の段数も含めて同じ型でなければならない
  - アドレスの比較を行いたい時は`std::ptr::eq`を使う
- 参照のアドレスをNULLにすることはできない
  - 値が存在しない可能性がある型としては`Option<&T>`を用いる
- 参照は任意の式に対して適用できる
  - 関数の戻り値などの値を直接参照に代入した場合、無名の変数が作成される
  - 無名変数の生存期間は参照に依存する
- 2種類のファットポインタ
  - スライスの参照
    - アドレスと配列の長さを持つ
  - トレイトオブジェクト
    - アドレスとトレイトの実装を持つ
- 参照はその使われ方によって生じる制約を反映した生存期間(lifetime)が割り当てられる
  - 生存期間とはその参照を安全に利用できる期間
  - 参照の生存期間はコンパイル時に存在するものであり実行時には存在しない
