# OWNERSHIP

- 全ての値は１つの所有者のみに所有される
- 一部のプリミティブ型には所有権が適用されない（Copy型という）
- 参照カウントを用いることで１つの値が複数所有されることができる

# MOVE

- 代入や所有権の移動はポインタなどの値が移動するだけでHeap上の値が別の場所に移動されるわけではない
- vectorのindexアクセスではmoveできない
- Option型を使用することでindexアクセスした場合でも所有権を移動できる
- Copy型ではないものの簡単な考え方
  - 値をドロップする際に何かしなければならいものはCopy型ではない

# RcとArc

- RcかArcを利用することで複数の所有者を持つ値が作れる
- ArcはAtomic reference countでスレッド間で所有権を共有する時に利用する
  - スレッド間でRcを利用して所有権を利用することはできない

# 借用(borrowing)と参照(reference)

- 参照のルール
  - 共有参照
    - 共有参照を用いると読み取りはできるが書き込みはできない
    - いくらでも共有参照を持つことができる
    - 型Tの共有参照型は&T（ref Tと発音する)
  - 可変参照
    - 値の可変参照を用いると値を読み出すことも書き出すこともできる
    - 同じ値に対する可変参照とその他の参照は同時に存在できない
    - &mut TがTに対する可変参照（ref mute Tと発音する
    - 可変参照はCopy型ではない
    - 可変アクセスは排他アクセスになる
    - 可変参照の生存期間と重なって良いのはその可変参照から借用した参照だけ
  - 複数の読み出しか単一書き込みのルール
  - ある値の共有参照がある間は所有者であっても値を変更することができない
  - 値渡し
    - 関数に値の所有権を渡すこと
  - 参照渡し
    - 関数に値の参照を渡すこと。所有権は移動しない。
- 参照の解決はC++と違い明示的に行う必要がある
  - ただし、構造体メンバへのアクセスなどの`.`を使う場合は暗黙的に参照解決を行うことができる
  - 参照に代入をすると別の場所を指すようになる
    - これはC++の代入の動作とは異なる
- 参照の参照もある
  - .演算子は何段の参照でも参照解決を暗黙的に行う
- 比較演算子も参照解決して比較できる
  - ただし、参照の段数も含めて同じ型でなければならない
  - アドレスの比較を行いたい時は`std::ptr::eq`を使う
- 参照のアドレスをNULLにすることはできない
  - 値が存在しない可能性がある型としては`Option<&T>`を用いる
- 参照は任意の式に対して適用できる
  - 関数の戻り値などの値を直接参照に代入した場合、無名の変数が作成される
  - 無名変数の生存期間は参照に依存する
- 2種類のファットポインタ
  - スライスの参照
    - アドレスと配列の長さを持つ
  - トレイトオブジェクト
    - アドレスとトレイトの実装を持つ
- 参照はその使われ方によって生じる制約を反映した生存期間(lifetime)が割り当てられる
  - 生存期間とはその参照を安全に利用できる期間
  - 参照の生存期間はコンパイル時に存在するものであり実行時には存在しない
- Rustにおけるグローバルに該当するものはstaticと呼ばれる
  - staticは初期化されなければならない
  - 可変なstaticな変数はunsafeブロック内でしかアクセスできない
- 関数には生存期間パラメータを持たせることができる
  - 生存期間パラメータ`f<'a>(p: 'a i32)`の`'a`は「tick a」と発音する
- 参照型が他の型定義に含まれている場合、生存期間を明示しなければならない
- 仮引数やメンバ変数などは独立した生存期間にしないと制約がキツくなりすぎることがある
  - デフォルトではそれぞれ独立した生存期間が割り当てられる

# 式(expression)

- 式には値があり文にはない
- Rustは式言語である
  - すべてが式で構成される
- ifが式になるので三項演算子がない
- 式の種類
  - 配列リテラル：`[1, 2, 3]`
  - 繰り返し配列リテラル：`[0; 50]`
  - タプル：`(0, 1)`
  - グループ化：`(1 + 2)`
  - ブロック：`{ f(); g() }`
  - 制御フロー
    - `if ok { f() }`
    - `if ok { 1 } else { 0 }`
    - `if let Some(x) = f() { x } else { 0 }`
    - `match x { None => 0, _ => 1 }`
    - `for v in e { f(v); }`
    - `while ok { ok = f(); }`
    - `while let Some(s) = it.next() { f(x); }`
    - `loop { next_event(); }`
    - `break`
    - `continue`
    - `return 1`
  - マクロの実行：`println!("ok")`
  - 構造体リテラル：`Point { x: 0, y: 1 }`
  - タプルのフィールドアクセス：`pair.0`
  - 構造体のフィールドアクセス：`point.x`
  - メソッドの呼び出し：`point.translate(50, 50)`
  - 関数呼び出し：`stdin()`
  - インデックス：`arr[0]`
  - エラーチェック：`create_dir("tmp")?`
  - 論理/ビット単位Not：`!ok`
  - 符号反転：`-num`
  - 参照解決：`*ptr`
  - 借用：`&val`
  - 型キャスト：`x as u32`
  - 掛け算：`1 * 3`
  - 割り算：`4 / 2`
  - 余り（剰余）：`n % 2`
  - 足し算：`1 + 2`
  - 引き算：`3 - 2`
  - 左シフト：`1 << 10`
  - 右シフト：`1 >> 10`
  - ビット単位AND：`n & 1`
  - ビット単位排他OR：`n ^ 1`
  - ビット単位OR:`n | 1`
  - 小なり：`n < 1`
  - 小なりイコール：`n <= 1`
  - 大なり：`n > 1`
  - 大なりイコール：`n >= 1`
  - イコール：`n == 1`
  - ノットイコール：`n != 1`
  - 論理AND：`n.0 && n.1`
  - 論理OR:`n.0 || n.1`
  - 末尾を含まない範囲：`start .. stop`
  - 末尾を含む範囲：`start ..= stop`
  - 代入：`x = 1`
  - 複合代入
    - x *= 1
    - x /= 1
    - x %= 1
    - x += 1
    - x -= 1
    - x <<= 1
    - x >>= 1
    - x &= 1
    - x |= 1
    - x ^= 1
  - クロージャ：`|x, y| x + y`
- 式は全て左結合になっているK
- ブロックは値を生み出すので値を必要とする任意の場所で使用することができる
- elseのないifは()を返却しなければならない

# definition

- `let name: type = expression;`
- 識別指名は英字かアンダーバーで開始できる。数字は２文字目以降から使える。
- 初期化前に変数を使用するとエラーになる。
- ブロック内でアイテムの宣言をできる。
  - アイテムとはfn,struct,useなどプラグラムに対してグローバルで宣言される物を指す。
  - ブロック内で宣言されたfn内部からはそのブロックに存在する変数は利用できない
    - ブロック内の変数を参照する似た機能としてはクロージャがある

# if and match

- if
  - 条件式の値はbool型でなければならない
    - C、C＋＋とは異なり型の暗黙的変換をしない
  - 条件式を囲む()は必要ない
    - ()があるとRustのコンパイラは警告を表示する
  - {}は必須
  - else if や elseは省略することができる
    - elseブロックのないifは空のelseブロックがあった場合と同じ挙動をする
- match
  - match式は分岐のうちどれか１つだけを実行する
  - `-`はワイルドカードを示す（どの値にもマッチする）
    - 最後に書かないと警告の対象となる
    - コンパイラはこの種のmatchをC言語のswtichと同じようにジャンプテーブルに変換する
    - match式に定数式を利用する場合も同じように最適化が可能
      - この場合は定数式を定数との配列にして配列へのインデックスアクセスとしてコンパイルされる
        - コンパイルされたコードにはインデックスの範囲チェック以外に分岐は存在しない
  - `=>`の個々の左側にはさまざまなpatternを使える
    - Optionの実態を区別する
    - ある範囲の値にマッチする
    - タプルから値を取り出す
    - 構造体の個々のフィールドにマッチする
    - 参照解決をする
    - 値の一部から借用をすることもできる
  - Rustのパターンはそれ自体１つのミニ言語になっている

matchの一般的な形は次のようになっている

```rust
match value {
    pattern => expr,
    ...
}
```

- exprがブロックの場合には末尾のカンマは省略できる
- patternに値がマッチすると対応するexprを評価してmatch式は終了する
- 少なくとも１つにmatchされなけれがならない
- すべてのケースをカバーしないmatch式は許容されない
- ifとmatchの値はすべて同じ型でなければならない

if let式は次のような形になっている

```rust
if let pattern = expr {
    block1
} else {
    block2
}
```

- exprがpatternにマッチするならblock1が実行され、マッチしなければblock2が実行される
- elseは省略可能
- matchがあれはif let式を利用する必要はない
  - matchのpatternが1つだけの場合の省略形と考えることができる

## loop

- ループには4つの式がある
  - while
  - while let
  - loop
  - for in
- rustにはループも式になっているがwhileとforの値は常に()になっているのであまり意味がない
- loopは指定すれば値を返す
- ..演算子は範囲(range)を生成する。よくfor inで用いられる
  - 0..20はstd::opt::Range { start: 0, end: 20 }と同じ意味になる
  - std::iter::IntoIteratorトレイトを実装しているものはfor inでループ可能
  - Rangeは実装している
  - コレクションを参照にしてループするとコレクションの要素の参照に対するループになる
  - mutに対するループは、各要素のmutのループになる
- break式はループの中で機能する
  - rustではbreakはループの中でしか使用しない
  - breakに値を与えるとそれがループの値になる
- continueを使うと次のループに移れる
  - もし値がなければループは終了する
- loopの生存期間にラベルをつけることができる
  - ラベルを利用してネストした内側のループから外側のループを終了することができる
- breakには生存期間と値の両方を与えることができる
- ラベルはcontinueも使うことができる
- loopには終了しない式という意味での特別な型!が与えられている
  - この方に型が合致されなければならないというルールができようされない
  - !はstd::process::exitのシグネチャに利用される
  - !を返す関数は帰らない関数、発散する関数(divergent function)


## return式

- 関数から脱出し値を呼び出し元へ返す
- returnはreturn()の省略形
- 関数に明示的にreturnをかく必要はない
  - 関数の最後の式にセミコロンがなければその式の値が返却値となる
    - Rustでは広くこの方法が取られている

## 関数

- 関数を呼び出し方は３つある
  - 通常の関数呼び出し
  - メソッド呼び出し
  - 型関連関数の呼び出し
    - 型関連数は型パラメータを他の関数と同じような形で渡せないのでターボフィッシュを利用する
      - `Vec::<T>new()`

## フィールドと要素

- 構造体やタプルの要素にアクセスするためには`.`を利用する
- 配列の要素アクセスには`[n]`のようにする
- これらの値は代入できるため左辺値（lvalue）と呼ばれる

## 演算子

- &&と||は短絡評価を行う

## 代入

- Copy型でない限り代入はRustでは所有権の移動になる
  - 代入先にすでに値があった場合はその値はドロップされる
- 複合代入もサポートされている
- Cとは異なり連鎖代入はサポートされていない
- インクリメント、デクリメント演算子はない

## 型キャスト

- 通常は`as`演算子を用いる
- キャストの種類
  - 組み込み数値型の間ではキャストが可能
    - 狭い範囲しか持たない型へのキャストは値の丸めが行われる
    - 符号なしの型から符号ありの型へのキャストは符号拡張がされる
    - 浮動小数点から整数型へのキャストは0に近づくように丸められる
    - 大きい値を小さい型に変換する場合は最も近い値に変換される
  - bool、char、Cのenumのような方は任意の整数型にキャストできる
  - u16からcharへのキャストはutf8のサロゲートポイントを参照することを避けるために禁止されている
    - std::char::from_u32()を利用すればOption<char>が得られる
    - Unicodeテキストに関する処理は複雑なので言語レベルではなくライブラリレベルで処理するのが良い
    - u8はcharへキャストできる。u8の範囲0~255はすべて有効なunicodeへマッピングできるため
  - 安全でないポインタ型へのキャストも許される
- 参照方に関するいくつかの型変換は単純なのでキャスト内で実施できる
  - mut参照からmutでない参照への変換は自動で行われる
  - 参照解決型変換(Deref型変換: deref coercions)
    - 例
      - 型&stringから型&strへの変換は自動で行われる
      - 型&Vec[i32]から型&[i32]への変換は自動で行われる
      - &Box<T> -> &T
    - 組み込みトレイトDerefを実装している型に適用されるK

## closure

- 通常クロージャは|で囲まれた引数リストと式で構成される
- 返り値を明示的に書くこともできる
  - 返り値を書いた場合は式の部分はブロックにしなければならない

## Error handling

- Result型とパニックがある
- Result型
  - 外部の要因などによって生じた問題を表現するために用いられる
    - 間違った入力
    - ネットワークの切断
    - 権限の問題
    - etc
- パニック
  - 通常でではない種類のエラー、すなわち起こってはいけない種類のエラー処理に用いる
  - 何かプログラム自身のバグに起因すると思われる問題が発生したとき
    - 配列の範囲外へのアクセス
    - 整数のゼロによる除算
    - ErrであるResultに対する.expect()の呼び出し
    - アサートの失敗
  - プログラマがpanic!()マクロでパニックを直接起こすこともできる
  - パニックになったら次の2つから処理を選択できる
    - スタックを巻き戻すか
    - プロセスをアボードするか

## Panic

- panicは未定義の処理ではなく定義された処理
- ただし、怒っては行けない処理ではある
- スレッドの巻き戻しをキャッチしてスレッドを殺さずにする方法もある
- アボード
  - パニックを巻き戻している最中に.drop()メソッドでパニックが起きた場合、致命的な状態と見なされる。Rustは巻き戻しを中止してプロセスを強制終了する。
    - この動作はカスタマイズできる。コンパイル時に-Cpanic=abortと指定すると最初のパニックで即座にプロセスをアボートする。
      - このコンパイルオプションを指定するとスタックを巻き戻す必要がなくなるのでコンパイルしたバイナリのサイズは小さくなる

## Result

- パターン
  - matchを使う
  - is_ok()とis_error()
  - ok()
  - error()
  - unwrap_or(fallback)
  - unwrap_or_else(fallback_fn)
  - unwrap()
  - expect(message)
  - as_ref()
  - as_mut()
- is_okとis_error以外のメソッドは消費してしまうのでas_refと組み合わせて使用して借用すると良い
- Err型は省略した型エイリアスが定義されることがよくある
- エラーの表示
  - println!
    - フォーマットするのには{}と{:?}がある。{:?}では詳細な情報が出力できる
  - err.to_string()
    - エラーメッセージをString型で取得する
  - err.source()
    - エラーの原因になったエラーがあればSome(err)を返す
  - writeln!で標準エラーにエラーを出力することができる
  - eprintln!は出力した後にパニックになる
- エラーを伝播させるのには?演算子が便利
- 起きるはずのないえらの場合はunwrapやexpectなどでエラーを無視することができる
  - ただし、特定の場合はunwrapでパニックになるのは適切でない場合はあるので利用するメソッドには注意
- エラーを無視する場合は`let _ = some_function_returing_result()`とすると良い

### main()でのエラー処理

- main()の返り値の型は通常はResultではないので、`?`は使えない。
  - main()でエラー処理をする最も単純な方法は.expect()を使うこと
    - パニックが起きる
      - プロセスは0でない終了コードを返却する
      - ただし少し恐ろしいエラーメッセージが出る
- main()の返り値の型をResult型に変えてしまうこともできる。そうすれば?が使える。
  - エラー型がもっと複雑だったり、メッセージに詳細な情報を表示したいのであれば、自分でエラーメッセージを出力した方がよい。

### カスタムエラー型の宣言

```rust
#[derive(Debug, Clone)]
pub struct JsonError {
    pub message: STring,
    pub line: usize,
    pub column: usize,
}
```

- 上記はうまくいくが利用ｓｙが期待するように、このエラー型を標準のエラー型のように使えるようにするには、もう少し手を入れる必要がある

```rust
use std::fmt;

impl fmt::Display for JsonError {
    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {
        write!(f, "{} ({}:{}", self.message, self.line, self.column)
    }
}

impl std::error::Error for JsonError { }
```

- 上記を簡潔に記述できるクレートを利用すると次のように記述できる

```rust
use thiserror::Error;
#[derive(Error, Debug)]
#[error("{message:} ({line:}, {column:})")]
pub struct JsonError {
    message: String,
    line: usize,
    column: usize,
}
```

### なぜResultを使うのか

- Rustはプログラマに、エラーが起こる可能性のあるすべての場所で、ある種の決断を行い、それをコードとして記録することを要求する。
  - これはよいことだ。こうしておかないと、エラーを無視して処理を誤ることになる。
- 最も一般的な判断は、エラーを伝播することなので、それが１文字「?」で描けるようになっている。
  - このおかげて、CやGoで書く場合よりもコードが散らからないで済む。しかも、何が起こっているのかはわかる。
  - コードのある部分をちょっと見るだけで、エラーを伝播している場所を全てすることができる。
- エラーが起こり得るということがすべての関数の返り値の型になっているので、失敗する可能性のある関数とそうでないものがすぐわかる。
  - ある関数を、失敗する可能性があるものに変更した際には、返り値の方を帰ることになるので、コンパイラがその関数を使う部分を全て変更することを矯正してくれる。
- RustコンパイラがResult値が使えわれているかどうかをチェックしてくれる。
  - このため、エラーを誤って無視してしまうことはできない（これはCではよくある過ちだ）。
- Resultは他の型と同様にデータ型なので、成功時の結果とエラー時の結果を同じコレクションに格納することが簡単にできる。
  - これによって、部分的な成功を表現するのが容易になる。
  - 例えば100万レコードをテキストファイルから読み出すプログラムを書いていて、ほとんどが成功して一部が失敗するという、ありがちな結果に対応する必要があるとしよう。
    - RustではResultのベクタをメモリ上に持ってこの状況を表現することができる

## クレートとモジュール

### クレート

- 依存するクレートがさらに依存するクレートを推移依存クレートと呼ぶ
- Cargoが依存グラフを元にビルドの順番を自動で決定する
- ダウンロードしたクレートのソースコードは`--crate-type lib`オプションを指定してビルドされる
  - このようにすることでrustcはmain()を探さず、.rlibファイルを作るようになる
- 本体のプログラムをコンパイルする際には、オプションに`--crate-type bin`を指定する
- rustcコマンドを実行する際に、Cargoはそのクレートが利用するライブラリのファイル名を--externオプションで指定する
  - このおかげで、rustcがuse image::png::PNGEncoderのような行を処理する際に、imageがクレートの名前であることがわかり、コンパイル済みのクレートがディスク上のどこにあるか知ることができる。
- .rlibには実行ファイルに静的にリンクする
- .rlibには型情報も収められている
  - 次のようなことが確認できる
    - ライブラリの機能が実際にクレートに存在しているか
    - コードがそれを正しく使っているか
- cargo build --release
  - 最適化されたビルドが行われる
  - 実行速度が早い
  - コンパイルに時間がかかる
  - 整数のオーバーフローチェックをしない
  - debug_assert!()によるアサーションもスキップする
  - パニックの際に出力されるスタックトレースも一般にやや正確さを欠く

## エディション

- 互換性を維持しつつ破壊的な変更をRustのバージョンアップで行うための仕組み
- エディションが同一であれば互換性が保たれる
- エディションをアップデートすれば破壊的な変更を受け入れる代わりに新しい機能を利用することができる
- １つのプログラムに複数のエディションを混在させることもできる
  - エディション2015のクレートがエディション2021のクレートに依存することも可能
  - コンパイルされてしまえばエディションの相違は消えてしまう
- エディションは毎年更新されるわけではなくRustプロジェクトが必要だと判断した時にだけ更新される
  - 例えば2020エディションは存在しない
- ほとんどの場合は最新のエディションを使った方が良い。
- もし古いエディションで書いたクレートがあったら、cargo fixコマンドで新しいエディションに対応するように自動的にアップグレードできる場合もある。

## ビルドプロファイル

- コマンドとCargo.tomlの設定セクション
  - `cargo build`: [profile.dev]
  - `cargobuild --release`: [profile.release]
  - `cargo test`: [profile.test]
- プロファイラを利用する場合は最適化を行つつデバッグシンボルが着くようにコンパイルしなければならない