# OWNERSHIP

- 全ての値は１つの所有者のみに所有される
- 一部のプリミティブ型には所有権が適用されない（Copy型という）
- 参照カウントを用いることで１つの値が複数所有されることができる

# MOVE

- 代入や所有権の移動はポインタなどの値が移動するだけでHeap上の値が別の場所に移動されるわけではない
- vectorのindexアクセスではmoveできない
- Option型を使用することでindexアクセスした場合でも所有権を移動できる
- Copy型ではないものの簡単な考え方
  - 値をドロップする際に何かしなければならいものはCopy型ではない

# RcとArc

- RcかArcを利用することで複数の所有者を持つ値が作れる
- ArcはAtomic reference countでスレッド間で所有権を共有する時に利用する
  - スレッド間でRcを利用して所有権を利用することはできない

# 借用(borrowing)と参照(reference)

- 参照のルール
  - 共有参照
    - 共有参照を用いると読み取りはできるが書き込みはできない
    - いくらでも共有参照を持つことができる
    - 型Tの共有参照型は&T（ref Tと発音する)
  - 可変参照
    - 値の可変参照を用いると値を読み出すことも書き出すこともできる
    - 同じ値に対する可変参照とその他の参照は同時に存在できない
    - &mut TがTに対する可変参照（ref mute Tと発音する
    - 可変参照はCopy型ではない
    - 可変アクセスは排他アクセスになる
    - 可変参照の生存期間と重なって良いのはその可変参照から借用した参照だけ
  - 複数の読み出しか単一書き込みのルール
  - ある値の共有参照がある間は所有者であっても値を変更することができない
  - 値渡し
    - 関数に値の所有権を渡すこと
  - 参照渡し
    - 関数に値の参照を渡すこと。所有権は移動しない。
- 参照の解決はC++と違い明示的に行う必要がある
  - ただし、構造体メンバへのアクセスなどの`.`を使う場合は暗黙的に参照解決を行うことができる
  - 参照に代入をすると別の場所を指すようになる
    - これはC++の代入の動作とは異なる
- 参照の参照もある
  - .演算子は何段の参照でも参照解決を暗黙的に行う
- 比較演算子も参照解決して比較できる
  - ただし、参照の段数も含めて同じ型でなければならない
  - アドレスの比較を行いたい時は`std::ptr::eq`を使う
- 参照のアドレスをNULLにすることはできない
  - 値が存在しない可能性がある型としては`Option<&T>`を用いる
- 参照は任意の式に対して適用できる
  - 関数の戻り値などの値を直接参照に代入した場合、無名の変数が作成される
  - 無名変数の生存期間は参照に依存する
- 2種類のファットポインタ
  - スライスの参照
    - アドレスと配列の長さを持つ
  - トレイトオブジェクト
    - アドレスとトレイトの実装を持つ
- 参照はその使われ方によって生じる制約を反映した生存期間(lifetime)が割り当てられる
  - 生存期間とはその参照を安全に利用できる期間
  - 参照の生存期間はコンパイル時に存在するものであり実行時には存在しない
- Rustにおけるグローバルに該当するものはstaticと呼ばれる
  - staticは初期化されなければならない
  - 可変なstaticな変数はunsafeブロック内でしかアクセスできない
- 関数には生存期間パラメータを持たせることができる
  - 生存期間パラメータ`f<'a>(p: 'a i32)`の`'a`は「tick a」と発音する
- 参照型が他の型定義に含まれている場合、生存期間を明示しなければならない
- 仮引数やメンバ変数などは独立した生存期間にしないと制約がキツくなりすぎることがある
  - デフォルトではそれぞれ独立した生存期間が割り当てられる

# 式(expression)

- 式には値があり文にはない
- Rustは式言語である
  - すべてが式で構成される
- ifが式になるので三項演算子がない
- 式の種類
  - 配列リテラル：`[1, 2, 3]`
  - 繰り返し配列リテラル：`[0; 50]`
  - タプル：`(0, 1)`
  - グループ化：`(1 + 2)`
  - ブロック：`{ f(); g() }`
  - 制御フロー
    - `if ok { f() }`
    - `if ok { 1 } else { 0 }`
    - `if let Some(x) = f() { x } else { 0 }`
    - `match x { None => 0, _ => 1 }`
    - `for v in e { f(v); }`
    - `while ok { ok = f(); }`
    - `while let Some(s) = it.next() { f(x); }`
    - `loop { next_event(); }`
    - `break`
    - `continue`
    - `return 1`
  - マクロの実行：`println!("ok")`
  - 構造体リテラル：`Point { x: 0, y: 1 }`
  - タプルのフィールドアクセス：`pair.0`
  - 構造体のフィールドアクセス：`point.x`
  - メソッドの呼び出し：`point.translate(50, 50)`
  - 関数呼び出し：`stdin()`
  - インデックス：`arr[0]`
  - エラーチェック：`create_dir("tmp")?`
  - 論理/ビット単位Not：`!ok`
  - 符号反転：`-num`
  - 参照解決：`*ptr`
  - 借用：`&val`
  - 型キャスト：`x as u32`
  - 掛け算：`1 * 3`
  - 割り算：`4 / 2`
  - 余り（剰余）：`n % 2`
  - 足し算：`1 + 2`
  - 引き算：`3 - 2`
  - 左シフト：`1 << 10`
  - 右シフト：`1 >> 10`
  - ビット単位AND：`n & 1`
  - ビット単位排他OR：`n ^ 1`
  - ビット単位OR:`n | 1`
  - 小なり：`n < 1`
  - 小なりイコール：`n <= 1`
  - 大なり：`n > 1`
  - 大なりイコール：`n >= 1`
  - イコール：`n == 1`
  - ノットイコール：`n != 1`
  - 論理AND：`n.0 && n.1`
  - 論理OR:`n.0 || n.1`
  - 末尾を含まない範囲：`start .. stop`
  - 末尾を含む範囲：`start ..= stop`
  - 代入：`x = 1`
  - 複合代入
    - x *= 1
    - x /= 1
    - x %= 1
    - x += 1
    - x -= 1
    - x <<= 1
    - x >>= 1
    - x &= 1
    - x |= 1
    - x ^= 1
  - クロージャ：`|x, y| x + y`
- 式は全て左結合になっているK
- ブロックは値を生み出すので値を必要とする任意の場所で使用することができる
- elseのないifは()を返却しなければならない
