# OWNERSHIP

- 全ての値は１つの所有者のみに所有される
- 一部のプリミティブ型には所有権が適用されない（Copy型という）
- 参照カウントを用いることで１つの値が複数所有されることができる

# MOVE

- 代入や所有権の移動はポインタなどの値が移動するだけでHeap上の値が別の場所に移動されるわけではない
- vectorのindexアクセスではmoveできない
- Option型を使用することでindexアクセスした場合でも所有権を移動できる
- Copy型ではないものの簡単な考え方
  - 値をドロップする際に何かしなければならいものはCopy型ではない

# RcとArc

- RcかArcを利用することで複数の所有者を持つ値が作れる
- ArcはAtomic reference countでスレッド間で所有権を共有する時に利用する
  - スレッド間でRcを利用して所有権を利用することはできない

# 借用(borrowing)と参照(reference)

- 参照のルール
  - 共有参照
    - 共有参照を用いると読み取りはできるが書き込みはできない
    - いくらでも共有参照を持つことができる
    - 型Tの共有参照型は&T（ref Tと発音する)
  - 可変参照
    - 値の可変参照を用いると値を読み出すことも書き出すこともできる
    - 同じ値に対する可変参照とその他の参照は同時に存在できない
    - &mut TがTに対する可変参照（ref mute Tと発音する
    - 可変参照はCopy型ではない
    - 可変アクセスは排他アクセスになる
    - 可変参照の生存期間と重なって良いのはその可変参照から借用した参照だけ
  - 複数の読み出しか単一書き込みのルール
  - ある値の共有参照がある間は所有者であっても値を変更することができない
  - 値渡し
    - 関数に値の所有権を渡すこと
  - 参照渡し
    - 関数に値の参照を渡すこと。所有権は移動しない。
- 参照の解決はC++と違い明示的に行う必要がある
  - ただし、構造体メンバへのアクセスなどの`.`を使う場合は暗黙的に参照解決を行うことができる
  - 参照に代入をすると別の場所を指すようになる
    - これはC++の代入の動作とは異なる
- 参照の参照もある
  - .演算子は何段の参照でも参照解決を暗黙的に行う
- 比較演算子も参照解決して比較できる
  - ただし、参照の段数も含めて同じ型でなければならない
  - アドレスの比較を行いたい時は`std::ptr::eq`を使う
- 参照のアドレスをNULLにすることはできない
  - 値が存在しない可能性がある型としては`Option<&T>`を用いる
- 参照は任意の式に対して適用できる
  - 関数の戻り値などの値を直接参照に代入した場合、無名の変数が作成される
  - 無名変数の生存期間は参照に依存する
- 2種類のファットポインタ
  - スライスの参照
    - アドレスと配列の長さを持つ
  - トレイトオブジェクト
    - アドレスとトレイトの実装を持つ
- 参照はその使われ方によって生じる制約を反映した生存期間(lifetime)が割り当てられる
  - 生存期間とはその参照を安全に利用できる期間
  - 参照の生存期間はコンパイル時に存在するものであり実行時には存在しない
- Rustにおけるグローバルに該当するものはstaticと呼ばれる
  - staticは初期化されなければならない
  - 可変なstaticな変数はunsafeブロック内でしかアクセスできない
- 関数には生存期間パラメータを持たせることができる
  - 生存期間パラメータ`f<'a>(p: 'a i32)`の`'a`は「tick a」と発音する
- 参照型が他の型定義に含まれている場合、生存期間を明示しなければならない
- 仮引数やメンバ変数などは独立した生存期間にしないと制約がキツくなりすぎることがある
  - デフォルトではそれぞれ独立した生存期間が割り当てられる

# 式(expression)

- 式には値があり文にはない
- Rustは式言語である
  - すべてが式で構成される
- ifが式になるので三項演算子がない
- 式の種類
  - 配列リテラル：`[1, 2, 3]`
  - 繰り返し配列リテラル：`[0; 50]`
  - タプル：`(0, 1)`
  - グループ化：`(1 + 2)`
  - ブロック：`{ f(); g() }`
  - 制御フロー
    - `if ok { f() }`
    - `if ok { 1 } else { 0 }`
    - `if let Some(x) = f() { x } else { 0 }`
    - `match x { None => 0, _ => 1 }`
    - `for v in e { f(v); }`
    - `while ok { ok = f(); }`
    - `while let Some(s) = it.next() { f(x); }`
    - `loop { next_event(); }`
    - `break`
    - `continue`
    - `return 1`
  - マクロの実行：`println!("ok")`
  - 構造体リテラル：`Point { x: 0, y: 1 }`
  - タプルのフィールドアクセス：`pair.0`
  - 構造体のフィールドアクセス：`point.x`
  - メソッドの呼び出し：`point.translate(50, 50)`
  - 関数呼び出し：`stdin()`
  - インデックス：`arr[0]`
  - エラーチェック：`create_dir("tmp")?`
  - 論理/ビット単位Not：`!ok`
  - 符号反転：`-num`
  - 参照解決：`*ptr`
  - 借用：`&val`
  - 型キャスト：`x as u32`
  - 掛け算：`1 * 3`
  - 割り算：`4 / 2`
  - 余り（剰余）：`n % 2`
  - 足し算：`1 + 2`
  - 引き算：`3 - 2`
  - 左シフト：`1 << 10`
  - 右シフト：`1 >> 10`
  - ビット単位AND：`n & 1`
  - ビット単位排他OR：`n ^ 1`
  - ビット単位OR:`n | 1`
  - 小なり：`n < 1`
  - 小なりイコール：`n <= 1`
  - 大なり：`n > 1`
  - 大なりイコール：`n >= 1`
  - イコール：`n == 1`
  - ノットイコール：`n != 1`
  - 論理AND：`n.0 && n.1`
  - 論理OR:`n.0 || n.1`
  - 末尾を含まない範囲：`start .. stop`
  - 末尾を含む範囲：`start ..= stop`
  - 代入：`x = 1`
  - 複合代入
    - x *= 1
    - x /= 1
    - x %= 1
    - x += 1
    - x -= 1
    - x <<= 1
    - x >>= 1
    - x &= 1
    - x |= 1
    - x ^= 1
  - クロージャ：`|x, y| x + y`
- 式は全て左結合になっているK
- ブロックは値を生み出すので値を必要とする任意の場所で使用することができる
- elseのないifは()を返却しなければならない

# definition

- `let name: type = expression;`
- 識別指名は英字かアンダーバーで開始できる。数字は２文字目以降から使える。
- 初期化前に変数を使用するとエラーになる。
- ブロック内でアイテムの宣言をできる。
  - アイテムとはfn,struct,useなどプラグラムに対してグローバルで宣言される物を指す。
  - ブロック内で宣言されたfn内部からはそのブロックに存在する変数は利用できない
    - ブロック内の変数を参照する似た機能としてはクロージャがある

# if and match

- if
  - 条件式の値はbool型でなければならない
    - C、C＋＋とは異なり型の暗黙的変換をしない
  - 条件式を囲む()は必要ない
    - ()があるとRustのコンパイラは警告を表示する
  - {}は必須
  - else if や elseは省略することができる
    - elseブロックのないifは空のelseブロックがあった場合と同じ挙動をする
- match
  - match式は分岐のうちどれか１つだけを実行する
  - `-`はワイルドカードを示す（どの値にもマッチする）
    - 最後に書かないと警告の対象となる
    - コンパイラはこの種のmatchをC言語のswtichと同じようにジャンプテーブルに変換する
    - match式に定数式を利用する場合も同じように最適化が可能
      - この場合は定数式を定数との配列にして配列へのインデックスアクセスとしてコンパイルされる
        - コンパイルされたコードにはインデックスの範囲チェック以外に分岐は存在しない
  - `=>`の個々の左側にはさまざまなpatternを使える
    - Optionの実態を区別する
    - ある範囲の値にマッチする
    - タプルから値を取り出す
    - 構造体の個々のフィールドにマッチする
    - 参照解決をする
    - 値の一部から借用をすることもできる
  - Rustのパターンはそれ自体１つのミニ言語になっている

matchの一般的な形は次のようになっている

```rust
match value {
    pattern => expr,
    ...
}
```

- exprがブロックの場合には末尾のカンマは省略できる
- patternに値がマッチすると対応するexprを評価してmatch式は終了する
- 少なくとも１つにmatchされなけれがならない
- すべてのケースをカバーしないmatch式は許容されない
- ifとmatchの値はすべて同じ型でなければならない

if let式は次のような形になっている

```rust
if let pattern = expr {
    block1
} else {
    block2
}
```

- exprがpatternにマッチするならblock1が実行され、マッチしなければblock2が実行される
- elseは省略可能
- matchがあれはif let式を利用する必要はない
  - matchのpatternが1つだけの場合の省略形と考えることができる

## loop

- ループには4つの式がある
  - while
  - while let
  - loop
  - for in
- rustにはループも式になっているがwhileとforの値は常に()になっているのであまり意味がない
- loopは指定すれば値を返す
- ..演算子は範囲(range)を生成する。よくfor inで用いられる
  - 0..20はstd::opt::Range { start: 0, end: 20 }と同じ意味になる
  - std::iter::IntoIteratorトレイトを実装しているものはfor inでループ可能
  - Rangeは実装している
  - コレクションを参照にしてループするとコレクションの要素の参照に対するループになる
  - mutに対するループは、各要素のmutのループになる
- break式はループの中で機能する
  - rustではbreakはループの中でしか使用しない
  - breakに値を与えるとそれがループの値になる
- continueを使うと次のループに移れる
  - もし値がなければループは終了する
- loopの生存期間にラベルをつけることができる
  - ラベルを利用してネストした内側のループから外側のループを終了することができる
- breakには生存期間と値の両方を与えることができる
- ラベルはcontinueも使うことができる
- loopには終了しない式という意味での特別な型!が与えられている
  - この方に型が合致されなければならないというルールができようされない
  - !はstd::process::exitのシグネチャに利用される
  - !を返す関数は帰らない関数、発散する関数(divergent function)


## return式

- 関数から脱出し値を呼び出し元へ返す
- returnはreturn()の省略形
- 関数に明示的にreturnをかく必要はない
  - 関数の最後の式にセミコロンがなければその式の値が返却値となる
    - Rustでは広くこの方法が取られている

## 関数

- 関数を呼び出し方は３つある
  - 通常の関数呼び出し
  - メソッド呼び出し
  - 型関連関数の呼び出し
    - 型関連数は型パラメータを他の関数と同じような形で渡せないのでターボフィッシュを利用する
      - `Vec::<T>new()`

## フィールドと要素

- 構造体やタプルの要素にアクセスするためには`.`を利用する
- 配列の要素アクセスには`[n]`のようにする
- これらの値は代入できるため左辺値（lvalue）と呼ばれる

## 演算子

- &&と||は短絡評価を行う

## 代入

- Copy型でない限り代入はRustでは所有権の移動になる
  - 代入先にすでに値があった場合はその値はドロップされる
- 複合代入もサポートされている
- Cとは異なり連鎖代入はサポートされていない
- インクリメント、デクリメント演算子はない

## 型キャスト

- 通常は`as`演算子を用いる
- キャストの種類
  - 組み込み数値型の間ではキャストが可能
    - 狭い範囲しか持たない型へのキャストは値の丸めが行われる
    - 符号なしの型から符号ありの型へのキャストは符号拡張がされる
    - 浮動小数点から整数型へのキャストは0に近づくように丸められる
    - 大きい値を小さい型に変換する場合は最も近い値に変換される
  - bool、char、Cのenumのような方は任意の整数型にキャストできる
  - u16からcharへのキャストはutf8のサロゲートポイントを参照することを避けるために禁止されている
    - std::char::from_u32()を利用すればOption<char>が得られる
    - Unicodeテキストに関する処理は複雑なので言語レベルではなくライブラリレベルで処理するのが良い
    - u8はcharへキャストできる。u8の範囲0~255はすべて有効なunicodeへマッピングできるため
  - 安全でないポインタ型へのキャストも許される
- 参照方に関するいくつかの型変換は単純なのでキャスト内で実施できる
  - mut参照からmutでない参照への変換は自動で行われる
  - 参照解決型変換(Deref型変換: deref coercions)
    - 例
      - 型&stringから型&strへの変換は自動で行われる
      - 型&Vec[i32]から型&[i32]への変換は自動で行われる
      - &Box<T> -> &T
    - 組み込みトレイトDerefを実装している型に適用されるK

## closure

- 通常クロージャは|で囲まれた引数リストと式で構成される
- 返り値を明示的に書くこともできる
  - 返り値を書いた場合は式の部分はブロックにしなければならない

## Error handling

- Result型とパニックがある
- Result型
  - 外部の要因などによって生じた問題を表現するために用いられる
    - 間違った入力
    - ネットワークの切断
    - 権限の問題
    - etc
- パニック
  - 通常でではない種類のエラー、すなわち起こってはいけない種類のエラー処理に用いる
  - 何かプログラム自身のバグに起因すると思われる問題が発生したとき
    - 配列の範囲外へのアクセス
    - 整数のゼロによる除算
    - ErrであるResultに対する.expect()の呼び出し
    - アサートの失敗
  - プログラマがpanic!()マクロでパニックを直接起こすこともできる
  - パニックになったら次の2つから処理を選択できる
    - スタックを巻き戻すか
    - プロセスをアボードするか

## Panic

- panicは未定義の処理ではなく定義された処理
- ただし、怒っては行けない処理ではある
- スレッドの巻き戻しをキャッチしてスレッドを殺さずにする方法もある
- アボード
  - パニックを巻き戻している最中に.drop()メソッドでパニックが起きた場合、致命的な状態と見なされる。Rustは巻き戻しを中止してプロセスを強制終了する。
    - この動作はカスタマイズできる。コンパイル時に-Cpanic=abortと指定すると最初のパニックで即座にプロセスをアボートする。
      - このコンパイルオプションを指定するとスタックを巻き戻す必要がなくなるのでコンパイルしたバイナリのサイズは小さくなる

## Result

- パターン
  - matchを使う
  - is_ok()とis_error()
  - ok()
  - error()
  - unwrap_or(fallback)
  - unwrap_or_else(fallback_fn)
  - unwrap()
  - expect(message)
  - as_ref()
  - as_mut()
- is_okとis_error以外のメソッドは消費してしまうのでas_refと組み合わせて使用して借用すると良い
- Err型は省略した型エイリアスが定義されることがよくある
- エラーの表示
  - println!
    - フォーマットするのには{}と{:?}がある。{:?}では詳細な情報が出力できる
  - err.to_string()
    - エラーメッセージをString型で取得する
  - err.source()
    - エラーの原因になったエラーがあればSome(err)を返す
  - writeln!で標準エラーにエラーを出力することができる
  - eprintln!は出力した後にパニックになる
- エラーを伝播させるのには?演算子が便利
- 起きるはずのないえらの場合はunwrapやexpectなどでエラーを無視することができる
  - ただし、特定の場合はunwrapでパニックになるのは適切でない場合はあるので利用するメソッドには注意
- エラーを無視する場合は`let _ = some_function_returing_result()`とすると良い

### main()でのエラー処理

- main()の返り値の型は通常はResultではないので、`?`は使えない。
  - main()でエラー処理をする最も単純な方法は.expect()を使うこと
    - パニックが起きる
      - プロセスは0でない終了コードを返却する
      - ただし少し恐ろしいエラーメッセージが出る
- main()の返り値の型をResult型に変えてしまうこともできる。そうすれば?が使える。
  - エラー型がもっと複雑だったり、メッセージに詳細な情報を表示したいのであれば、自分でエラーメッセージを出力した方がよい。

### カスタムエラー型の宣言

```rust
#[derive(Debug, Clone)]
pub struct JsonError {
    pub message: STring,
    pub line: usize,
    pub column: usize,
}
```

- 上記はうまくいくが利用ｓｙが期待するように、このエラー型を標準のエラー型のように使えるようにするには、もう少し手を入れる必要がある

```rust
use std::fmt;

impl fmt::Display for JsonError {
    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {
        write!(f, "{} ({}:{}", self.message, self.line, self.column)
    }
}

impl std::error::Error for JsonError { }
```

- 上記を簡潔に記述できるクレートを利用すると次のように記述できる

```rust
use thiserror::Error;
#[derive(Error, Debug)]
#[error("{message:} ({line:}, {column:})")]
pub struct JsonError {
    message: String,
    line: usize,
    column: usize,
}
```

### なぜResultを使うのか

- Rustはプログラマに、エラーが起こる可能性のあるすべての場所で、ある種の決断を行い、それをコードとして記録することを要求する。
  - これはよいことだ。こうしておかないと、エラーを無視して処理を誤ることになる。
- 最も一般的な判断は、エラーを伝播することなので、それが１文字「?」で描けるようになっている。
  - このおかげて、CやGoで書く場合よりもコードが散らからないで済む。しかも、何が起こっているのかはわかる。
  - コードのある部分をちょっと見るだけで、エラーを伝播している場所を全てすることができる。
- エラーが起こり得るということがすべての関数の返り値の型になっているので、失敗する可能性のある関数とそうでないものがすぐわかる。
  - ある関数を、失敗する可能性があるものに変更した際には、返り値の方を帰ることになるので、コンパイラがその関数を使う部分を全て変更することを矯正してくれる。
- RustコンパイラがResult値が使えわれているかどうかをチェックしてくれる。
  - このため、エラーを誤って無視してしまうことはできない（これはCではよくある過ちだ）。
- Resultは他の型と同様にデータ型なので、成功時の結果とエラー時の結果を同じコレクションに格納することが簡単にできる。
  - これによって、部分的な成功を表現するのが容易になる。
  - 例えば100万レコードをテキストファイルから読み出すプログラムを書いていて、ほとんどが成功して一部が失敗するという、ありがちな結果に対応する必要があるとしよう。
    - RustではResultのベクタをメモリ上に持ってこの状況を表現することができる

## クレートとモジュール

### クレート

- 依存するクレートがさらに依存するクレートを推移依存クレートと呼ぶ
- Cargoが依存グラフを元にビルドの順番を自動で決定する
- ダウンロードしたクレートのソースコードは`--crate-type lib`オプションを指定してビルドされる
  - このようにすることでrustcはmain()を探さず、.rlibファイルを作るようになる
- 本体のプログラムをコンパイルする際には、オプションに`--crate-type bin`を指定する
- rustcコマンドを実行する際に、Cargoはそのクレートが利用するライブラリのファイル名を--externオプションで指定する
  - このおかげで、rustcがuse image::png::PNGEncoderのような行を処理する際に、imageがクレートの名前であることがわかり、コンパイル済みのクレートがディスク上のどこにあるか知ることができる。
- .rlibには実行ファイルに静的にリンクする
- .rlibには型情報も収められている
  - 次のようなことが確認できる
    - ライブラリの機能が実際にクレートに存在しているか
    - コードがそれを正しく使っているか
- cargo build --release
  - 最適化されたビルドが行われる
  - 実行速度が早い
  - コンパイルに時間がかかる
  - 整数のオーバーフローチェックをしない
  - debug_assert!()によるアサーションもスキップする
  - パニックの際に出力されるスタックトレースも一般にやや正確さを欠く

## エディション

- 互換性を維持しつつ破壊的な変更をRustのバージョンアップで行うための仕組み
- エディションが同一であれば互換性が保たれる
- エディションをアップデートすれば破壊的な変更を受け入れる代わりに新しい機能を利用することができる
- １つのプログラムに複数のエディションを混在させることもできる
  - エディション2015のクレートがエディション2021のクレートに依存することも可能
  - コンパイルされてしまえばエディションの相違は消えてしまう
- エディションは毎年更新されるわけではなくRustプロジェクトが必要だと判断した時にだけ更新される
  - 例えば2020エディションは存在しない
- ほとんどの場合は最新のエディションを使った方が良い。
- もし古いエディションで書いたクレートがあったら、cargo fixコマンドで新しいエディションに対応するように自動的にアップグレードできる場合もある。

## ビルドプロファイル

- コマンドとCargo.tomlの設定セクション
  - `cargo build`: [profile.dev]
  - `cargobuild --release`: [profile.release]
  - `cargo test`: [profile.test]
- プロファイラを利用する場合は最適化を行つつデバッグシンボルが着くようにコンパイルしなければならない

## モジュール

- クレート：プロジェクト間のコード共有のため
- モジュール：プロジェクト内部のコード構造化のため
  - 名前空間
    - 関数、型、定数などを収めるコンテナ
- アイテム：構造体や関数のように名前が追加機能の総称
  - モジュールはアイテムの集合体
- pubキーワードは、モジュールの外からアクセスできるようにする
  - pubとされていないものはすべてプライベートとなり、それが定義されたモジュールもしくはその子モジュールからしかアクセスできない
  - アイテムをpubとすることをエクスポートするという。
- 必要に応じてモジュールをネストし、複数のファイルやディレクトに分けることができる
- Rustで他のモジュールのアイテムを参照するために用いるパス記法がある
- アイテムをインポートすることでフルパスで指定せずにそのアイテムを利用できるようになる
- Rustの構造体のフィールドに対する細粒度なアクセス制御ができる
- preludeモジュールがある
  - これはほとんどすべてのユーザが必要とするような一般的なインポートを集めたもので、定型句を各労力を減らしてくれる
- プログラムをわかりやすく生合成の取れたものにするために、値に名前を与えたい場合がある。
  - これを実現する手法として、定数とstaticの2つがある

## モジュールをネストする

```rust
mod plant_structures {
    pub mod roots {
        // ...
    }
    
    pub mod stems {
        // ...
    }
    
    pub mod leaves {
        // ...
    }
}
```

- pub(super)とすると、親モジュールから飲みアクセス可能になる。
- pub(in <path>)のように書いて、特定の親モジュールとその子孫からの身アクセスできるようにすることもできる。
  - この記法は、ネストが深くなったモジュールで特に有効だ

### パスとインポート

- 任意の標準ライブラリの機能は絶対パスで参照できる
  - ex: `std::mem::swap('mut s1, 'mut s2);`
- 機能をインポートすればパスを省略して利用できる
- use宣言はブロックでもできる
- `use std::mem::swap`として関数そのものをインポートできるが一般的には`std::mem`などとして早退パスでアクセスするのが良いスタイルとされている
- 複数の名前を同時にインポートすることもできる
  - `use std::collections::{HashMap, HashSet};`
- 全てインポート
  - `use std::io::prelude::*;`
- asを使ってローカルな別名を与えることができる
  - `use std::io::Result as IOResult`
- モジュールは親モジュールの名前空間を自動的に引き継がない。
- キーワードsuperとcrateはパス中で特別な意味を持つ。
  - super: 親モジュール
  - crate: 減災のモジュールを含むクレートを指す
    - crateルートからの早退パスを用いると現在のモジュールのパスが変わってもインポートが壊れない
- 利用しているクレート名とモジュール名が被った時
  - 外部のimageクレートのPixels型を算用するには次のように書く
    - `use ::image::Pixels;`
  - 自分のimageモジュールのSampler型を参照するには次のように書く
    - `use self::image::Sampler;`
- use宣言はエイリアスを作るだけだが、これもパブリックにすることができる。
  - こうするとモジュールのパブリックアイテムになる。
  - 標準のプレリュードには、このようなpubインポートが並んでいる。
- 構造体のフィールドは、プライベートフィールドであっても、その構造体が定義されたモジュール内部とそのサブモジュールからはアクセスできる。
  - モジュールの外からはパブリックフィールドだけがアクセスできる。
- モジュールには、関数、型、ネストしたモジュールに加えて、定数とstaticを定義することができる。
  - 定数を導入するにはconstキーワードを用いる。
    - 構文はletと似ているが、必要なｒあpubがつくことと、型を必ず指定する必要がある点が異なる。
    - 定数は慣例として、UPPERCASE_NAMESのように全て大文字にし単語感はアンダースコアで区切る。
  - staticキーワードは、staticアイテムを導入する。
    - staticアイテムと定数はほとんど同じ
    - `pub static ROOM_TEMPERATURE: f64 = 68.0;`
  - 定数は、C++の#defineに似ていて、相対を使うすべての場所に値がコンパイル時に埋め込まれる。
  - staticは、プログラムが実行を開始する前に用意され、終了するまで生き残る変数
  - マジックナンバーやマジック文字列には定数を使う
  - データが大き場合などの理由で、その低通知への参照を借用する必要があるならstaticを使う
  - 定数はmutにできない。
  - staticはmutをつけることができる
    - 排他的なアクセスを矯正する方法がない
    - 本質的にスレッド安全でないので、安全なコードからは全く使うことができない
    - グローバルで可変な状態は推奨されない

## プログラムからライブラリに変更する手順

- src/main.rsをsrc/lib.rsに変更する
- src/lib.rsのパブリックな機能となるべきものにpubキーワードをつける
  - src/lib.rsのコードがライブラリのルートモジュールを構成する。
    - このライブラリを用いる他のクレートは、このツーとモジュールのパブリックアイテムにしかアクセスできない
- main関数はsrc/binディレクトリに適当な名前で配置するとライブラリにもブログラムが作成できる
  - src/bin/efern.rsという名前にした場合`cargo run --bin efern`とすれば実行できる

## 属性

- Rustプログラム中のアイテムはどれにでも、属性を付与することができる
- 属性は、コンパイラへの様々な指令やアドバイスを書くための、何に絵でも使える構文
  - 警告の非表示制御
    - `#[allow(non_camel_case_types)]`
  - 条件付きコンパイル
    - `#[cfg[target_os = "android")]`
  - 関数のインライン展開
    - `#[inline]`
      - 関数のインライン展開は普通はコンパイラ任せにするが、属性をつけないとインライン展開されない場合がある
        - あるクレートに宣言されている関数やメソッドを別のクレートから使う場合、それがジェネリックであるか、#[inline]属性がついていない限り、インライン展開は行われない
    - `#[inline(always)]`
    - `#[inline(never)]`
  - #!をつけてモジュール全体に付与することもできる
    - 属性によってはクレート全体にしか付与できないので、常に#!構文を使うものもある
      - #![feature]属性は、Rustの言語やライブラリの不安定な機能を使用するために用いる

## テストとドキュメント

- assert!やassert_eq!はリリースビルドにも入ってしまう
- デバッグビルド時だけチェックしないのであれば、debug_assert!、debug_assert_eq!を用いる
- エラーが起きる場合はをテストしたいなら、テストに#[should_panic]属性をつける
- テスト関数はResult<(), E>を返してもよい。
  - エラーのヴァリアントがDebugを実装していれば（通常は実装している）、?を使って結果を返すことができる。
- `#[test]`が付けられた関数は、条件付きでコンパイルされる。
  - 通常の`cargo build`や`cargo build --release`では、テストコードはスキップされる。
  - しかし、cargo testとすると、Cargoはプログラムを2回ビルドする。
  - 1回は通常の方法で、もう1回はテスト用関数とテストツールを有効にしてビルドする。
  - このため、ユニットテストのコードをテスト対象コードのすぐと隣におくことができる。
  - また、必要であればテストコードから実装内部の細部にアクセすることができ、しかも実行時コストはかからない
    - ただし、警告が出る場合もある。
  - #[cfg(test)]を使ってモジュール全体をテスト時にしかビルドできないようにできる
- Rustは複数のスレッドを用いて、複数のテストを同時に行う
  - これを行わないようにするには`cargo test -- --test-threads 1`としてシングルスレッドで実行すればいい
- テストは失敗したテストの結果しか出力しない。
  - 成功したテストの結果も表示するには`cargo test -- --no-capture`とすればよい
- srcディレクトリと同じ階層のtestsディレクトリにrsファイルをおくことで結合テストを記述することができる。
  - Cargoはここの結合テストを個別の独立したクレートとしてコンパイルし、対象なるライブラリとテストツールとにリンクする。

## ドキュメント

- cargo docとするとライブラリのHTMLどｋｙｊ面とが生成される
  - `--no-deps`オプションで、依存先のクレートのドキュメントを作らず、指定したバイナリのドキュメントだけを生成するように指定できる
  - `--open`で、生成したドキュメントをブラウザで開くようにできうる
  - Cargoは生成したドキュメントをtarget/docに格納する
    - トップページはtarget/doc/${crate_name}/index.htmlになる
  - ドキュメントは、ライブラリに収められたpubのついたアイテムと、それらに付随するドキュメント(doc comments)から生成される
    - ３つのスラッシュで始まるコメントはコンパイラによって#[doc]属性として解釈される
      - ライブラリや実行ファイルをコンパイルする際には、この属性は無視される。
    - 同様に`//!`で始めるコメントは、#![doc]属性として扱われ、それが書かれたアイテム（一般的にはモジュールかクレート）に対して付与される。
- ドキュメントコメントの内容は、Markdown形式として扱われる
- Rustのドキュメントコメントの特別な機能の１つとして、別のアイテムを参照する際に、MarkdownのリンクにRustのアイテムパスを使う機能がある
- 検索エイリアスもつけることができる
  - 例：`#[doc(alias = "route")]`
- 外部ファイルをドキュメントに含める機能がある
  - 例：`#![doc = include_str!("../README.md")]
- コード書く場合にはバッククォーとを用いる。より大きなコードサンプルを表示したい場合は４つのスペースでインデントする
  - Markdown形式で書いても良い。
- Rustのライブラリクレートのテストを実行すると、Rustはドキュメントないに現れるすべてのコードが実際に実行でき、動作かうるかチェックする。
- インポートなどのコードなどドキュメントに出力したくない行は`#`で開始することで出力をやめられる
- ドキュメントのフェンスコードブロックにno_run属性を追加するとテストは実行されなくなる
- コンパイルもしないようにするにはignore属性を利用する
- そのたtextなどの属性にすればテストは実行されない

## 依存ライブラリの指定

- 依存ライブラリとバージョンをCargo.tomlに指定する
  - バージョンを"0.13.0"と指定した場合バージョン"0.13.0"と互換性があると思われる最も新しいバージョンを取得する
    - 0.0で始まるバージョン番号は未成熟なものと考えられるので、他のバージョンとは互換性がないとされる
    - 0.xで始めるバージョン番号は他の0.xシリーズのポイントリリースと互換性があると考える
      - 0.6.1に設定したが、0.6.4があればそちらを使う
    - プロジェクトが1.0まで達したら、メジャーバージョンの変更以外では互換性は名倉内。
      - 2.0.1を要求した場合、Cargoが2.17.99を使うことはあるが、3.0を使うことはない
  - `image = "=0.10.0"`: 厳密にバージョン0.10.0だけを使う
  - `image = ">=1.0.5"`: 1.0.5もしくは、それ以上の任意のバージョンを用いる（もしあれば、2.9でも構わない）
  - `image = ">1.0.5<1.1.9`: 1.0.5よりも大きく、1.1.9よりも小さいバージョン
  - `image = "<=2.7.10"`: 2.7.10以下の任意のバージョン
- 公開されていないライブラリを追加するにはURLとリビジョンを指定する方法がある
- クレートが存在するディレクトリを指定する方法もある
- Cargo.lockにはすべての使用したクレートの正確なバージョンが書き込まれる
  - その後のビルドで利用される
  - 更新されるのは以下のタイミング
    - Cargo.tomlでバージョンの指定を変更したとき
    - `cargo update`をしたとき
      - 互換性のある最新バージョンを取得する
  - ライブライのプロジェクトの場合にはCargo.lockをコミットする必要はない
    - ライブラリのユーザーには、彼らの依存グラフ全体のバージョン情報が書き込まれたCargo.lockファイルがあるはず。
    - ただし、共有ライブラリを作るプロジェクトの場合(dll,dylib,soなど)には、利用者はcargoを使わないで、Cargo.lockをコミットするべき
